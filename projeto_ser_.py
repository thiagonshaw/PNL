# -*- coding: utf-8 -*-
"""Projeto Ser .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OH-G98an0-Bp3raRgAcclEodDuOq0ncb
"""

!pip install nltk unidecode

from google.colab import drive
import pandas as pd
import numpy as np
import gcsfs
import os
import matplotlib.pyplot as plt
import seaborn as sns
import re
import nltk
from unidecode import unidecode
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer
from scipy import stats

nltk.download('stopwords')

drive.mount('/content/drive')

# Caminho para a pasta onde a pasta '711E5097-06EA-4F3F-BF49-DC960808C70F' está localizada
folder_path = '/content/drive/My Drive/ser/711E5097-06EA-4F3F-BF49-DC960808C70F'

# Nomes dos arquivos CSV a serem unificados
file_names = [
    '711E5097-06EA-4F3F-BF49-DC960808C70F_feedback.csv',
    '711E5097-06EA-4F3F-BF49-DC960808C70F_vendas.csv'
]
# Carregar todos os arquivos CSV em uma lista de DataFrames
dfs = [pd.read_csv(os.path.join(folder_path, file)) for file in file_names]

feedback_df, vendas_df = dfs

vendas_df['Data'] = pd.to_datetime(vendas_df['Data'])
feedback_df['Data'] = pd.to_datetime(feedback_df['Data'])

# convertendo para string
feedback_df['Resposta'] = feedback_df['Resposta'].astype(str)

print(feedback_df['Resposta'].dtype)

# Listas de palavras positivas e negativas
palavras_positivas = [
    "otimo", "bom", "excelente", "satisfatorio", "positivo", "eficiente", "competente",
    "organizado", "motivador", "atencioso", "flexivel", "agradavel", "reconhecido",
    "proativo", "proativa", "confiavel", "entusiasmado", "entusiasmada", "capaz",
    "qualificado", "qualificada", "produtivo", "produtiva", "rapido", "rapida",
    "pontual", "efetivo", "efetiva", "superior", "inovador", "inovadora", "admiravel",
    "aprovado", "aprovada", "eficaz", "fantastico", "fantastica", "incrivel", "otima",
    "parabéns", "comprometido", "comprometida", "satisfeito", "uma boa", "carismatico",
    "carismatica", "muito focado", "bacana", "cordial", "colaborador", "eficiência",
    "disciplina", "comportado", "exemplar", "guerreira", "destaque", "relacionamento",
    "disposição", "ajudar", "postura", "potencial", "melhora", "qualidade", "carinho",
    "sorriso", "simpatia", "metas batidas", "acima do esperado", "acima da média",
    "atende bem", "correto", "corretamente", "focado", "disposto", "elogios", "pontualidade",
    "focada", "articulado", "dedicado", "engajado", "valoroso", "energético", "habilidoso",
    "talentoso", "profissional", "bem-sucedido", "perspicaz", "promissor", "esforçado",
    "disciplinado", "disciplinada", "compromissado", "compromissada"
]

palavras_negativas = [
    "ruim", "pessimo", "pessima", "insatisfatorio", "insatisfatoria", "negativo",
    "negativa", "ineficiente", "incompetente", "irresponsavel", "desorganizado",
    "desorganizada", "lento", "lenta", "desmotivado", "desmotivada", "desleixado",
    "desleixada", "desatencioso", "desatenciosa", "inflexivel", "irritado", "irritada",
    "desrespeitoso", "desrespeitosa", "nao profissional", "negligente", "imprudente",
    "ineficaz", "improdutivo", "improdutiva", "indisciplinado", "indisciplinada",
    "desobediente", "insubordinado", "insubordinada", "incompreensivel", "incoerente",
    "desconfiavel", "preguiçoso", "preguiçosa", "relapso", "teimoso", "teimosa",
    "desinteressado", "desinteressada", "caotico", "caotica", "critico", "critica",
    "dificuldade", "disfuncional", "desagradavel", "desaprovacao", "desastroso",
    "desastrosa", "deteriorado", "deteriorada", "desgostoso", "desgostosa", "desonesto",
    "desonesta", "decepcionante", "defeituoso", "defeituosa", "deficiente", "demorado",
    "demorada", "desafio", "desprezivel", "inaceitavel", "inadmissivel", "inapto",
    "inapta", "inconveniente", "indesejavel", "ineficacia", "ineficiencia", "inferior",
    "lamentavel", "mediocre", "problematico", "problematica", "reprovavel", "ridiculo",
    "ridicula", "sofrivel", "toleravel", "triste", "vexatorio", "vexatoria",
    "vulneravel", "impontual", "desestruturado", "desestruturada", "insensivel",
    "intolerante", "insuficiente", "inepto", "inepta", "indolente", "infeliz",
    "ingrato", "ingrata", "ruindade", "substandard", "fracasso", "insatisfacao",
    "fracassado", "fracassada", "insolente", "incapaz", "deploravel", "atroz",
    "impertinente", "nulo", "constrangedor", "constrangedora", "desolador",
    "desoladora", "decaido", "decaida", "indelicado", "indelicada", "falho",
    "prejudicial", "incorreto", "incorreta", "irregular", "irritante", "inadequado",
    "inadequada", "nauseante", "abominavel", "devendo", "desligado", "oscilar",
    "mediano", "apagado", "vibração", "baixo", "escorado", "problemas pessoais",
    "atrasos", "advertência", "constante atraso", "abaixo do esperado", "abaixo da média",
    "apático"
]

palavras_neutras = [
    "precisa melhorar", "adequado", "regular", "aceitável", "normal",
    "pode melhorar", "esperado", "ok", "razoável", "suficiente", "precisa",
    "precisando", "precisando melhorar"
]

# Função para normalizar o texto
def normalizar_texto(texto):
    texto = unidecode(texto).lower()
    texto = re.sub(r'[^\w\s]', '', texto)
    return texto

# Função para analisar o sentimento
def analisar_sentimento(texto):
    """
    Analisa o sentimento do texto utilizando uma lista de palavras-chave
    e regras básicas para sarcasmo e ironia.
    """
    texto_normalizado = normalizar_texto(texto)

    # Detecta sarcasmo básico com pontuações de exclamação
    if re.search(r"!+!", texto_normalizado):
        return 0  # sarcasmo_negativo como negativo

    # Analisa o sentimento com base na lista de palavras-chave
    pontuacao_sentimento = 0
    for palavra in texto_normalizado.split():
        if palavra in [unidecode(p).lower() for p in palavras_positivas]:
            pontuacao_sentimento += 1
        elif palavra in [unidecode(p).lower() for p in palavras_negativas]:
            pontuacao_sentimento -= 1
        elif palavra in [unidecode(p).lower() for p in palavras_neutras]:
            pontuacao_sentimento += 0  # Sem alteração na pontuação para neutro

    # Verifica se o texto contém uma nota válida (0 a 5), ignorando datas e números acima de 5
    notas = [int(n) for n in re.findall(r'\b\d+\b', texto) if 0 <= int(n) <= 5]

    # Ignorar datas nos formatos DD/MM e DD-MM-YYYY
    datas_formatadas = re.findall(r'\b\d{2}/\d{2}\b', texto) + re.findall(r'\b\d{2}-\d{2}-\d{4}\b', texto)
    if any(data in datas_formatadas for data in re.findall(r'\b\d{2}/\d{2}\b', texto)) or \
       any(data in datas_formatadas for data in re.findall(r'\b\d{2}-\d{2}-\d{4}\b', texto)):
        return 3  # neutro

    if notas:
        nota = notas[0]
        if nota in [4, 5]:
            return 5  # positivo
        elif nota in [0, 1, 2]:
            return 0  # negativo
        else:
            return 3  # neutro

    # Determina o sentimento com base nas contagens
    if pontuacao_sentimento > 0:
        return 5  # positivo
    elif pontuacao_sentimento < 0:
        return 0  # negativo
    else:
        return 3  # neutro

# Função para categorizar a média dos sentimentos
def categorizar_media(media):
    if media < 1.5:
        return 'negativo'
    elif 1.5 <= media <= 3.5:
        return 'neutro'
    else:
        return 'positivo'

def handle_nan_strings(df, column_name):
  """
  Replaces 'nan' strings with NaN values and drops rows with NaN values in the specified column.

  Args:
      df (pandas.DataFrame): The DataFrame containing the column with NaN strings.
      column_name (str): The name of the column to process.

  Returns:
      pandas.DataFrame: The DataFrame with NaN values handled and rows with NaN dropped.
  """
  df.replace('nan', pd.NA, inplace=True)
  df.dropna(subset=[column_name], inplace=True)
  return df

# Apply the function to handle NaN strings in 'Resposta' column
feedback_df = handle_nan_strings(feedback_df.copy(), 'Resposta')

# Ajustando os nomes das colunas para facilitar a junção
feedback_df.rename(columns={'Funcionario_Avaliado': 'Funcionario'}, inplace=True)

# Removendo as colunas
feedback_df.drop(columns=['cli_codigo', 'Processo'], inplace=True, errors='ignore')
vendas_df.drop(columns=['cli_codigo', 'Vlr_Desconto'], inplace=True, errors='ignore')

# Aplica a função de análise de sentimento à coluna 'Resposta'
feedback_df['Sentimento'] = feedback_df['Resposta'].apply(analisar_sentimento)

# Calcula a média dos sentimentos para cada funcionário
feedback_df['Media_Sentimento'] = feedback_df.groupby('Funcionario')['Sentimento'].transform('mean')

# Aplica a função de categorização à média dos sentimentos
feedback_df['Feedback'] = feedback_df['Media_Sentimento'].apply(categorizar_media)

# Fazendo a junção das tabelas
vendas_feedback_df = pd.merge(vendas_df, feedback_df, on='Funcionario', how='left')

# Função para calcular a moda usando scipy
def moda(x):
    # Use numpy's unique function to find the mode
    values, counts = np.unique(x, return_counts=True)
    mode_value = values[np.argmax(counts)]
    return mode_value

# Agrupando e aplicando as agregações
vendas_feedback_df = vendas_feedback_df.groupby(['Data_x', 'Funcionario', 'Unidade']).agg({
    'N_Boletos': 'mean',
    'N_Produtos': 'mean',
    'Vlr_Bruto': 'mean',
    'Vlr_Liquido': 'mean',
    'Feedback': moda

}).reset_index()

vendas_feedback_df['Feedback'] = vendas_feedback_df['Feedback'].fillna('n/a')

vendas_feedback_df

from matplotlib import pyplot as plt
import seaborn as sns
vendas_feedback_df.groupby('Feedback').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

plt.xlim(0, 200000)

# Definir o tamanho da figura
figsize = (12, 1.2 * len(vendas_feedback_df['Feedback'].unique()))
plt.figure(figsize=figsize)

# Criar o gráfico de violino
sns.violinplot(x='Vlr_Bruto', y='Feedback', data=vendas_feedback_df, inner='box', palette='Dark2')

# Remover bordas superiores e laterais
sns.despine(top=True, right=True)
plt.xlim(-2000, 10000)

# Exibir o gráfico
plt.show()

# Filtrar os dados para incluir apenas o sentimento 'Positivo'
df_positivo = vendas_feedback_df[vendas_feedback_df['Feedback'] == 'positivo']

media_total_vlr_bruto = df_positivo['Vlr_Bruto'].mean()
print(f"Total {media_total_vlr_bruto}")

vendas_feedback_df

# Salvar como CSV
vendas_feedback_df.to_csv('/content/drive/My Drive/vendas_com_feedback.csv', index=False)